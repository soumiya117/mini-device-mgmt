'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

var _jestGetType = require('jest-get-type');

var _jestMatcherUtils = require('jest-matcher-utils');

var _jasmineUtils = require('./jasmineUtils');

var _utils = require('./utils');

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// The optional property of matcher context is true if undefined.
const isExpand = expand => expand !== false;

const PRINT_LIMIT = 3;
const NO_ARGUMENTS = 'called with 0 arguments';

const printExpectedArgs = expected =>
  expected.length === 0
    ? NO_ARGUMENTS
    : expected.map(arg => (0, _jestMatcherUtils.printExpected)(arg)).join(', ');

const printReceivedArgs = (received, expected) =>
  received.length === 0
    ? NO_ARGUMENTS
    : received
        .map((arg, i) =>
          Array.isArray(expected) &&
          i < expected.length &&
          isEqualValue(expected[i], arg)
            ? printCommon(arg)
            : (0, _jestMatcherUtils.printReceived)(arg)
        )
        .join(', ');

const printCommon = val =>
  (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));

const isEqualValue = (expected, received) =>
  (0, _jasmineUtils.equals)(expected, received, [_utils.iterableEquality]);

const isEqualCall = (expected, received) => isEqualValue(expected, received);

const isEqualReturn = (expected, result) =>
  result.type === 'return' && isEqualValue(expected, result.value);

const countReturns = results =>
  results.reduce((n, result) => (result.type === 'return' ? n + 1 : n), 0);

const printNumberOfReturns = (countReturns, countCalls) =>
  `\nNumber of returns: ${(0, _jestMatcherUtils.printReceived)(countReturns)}` +
  (countCalls !== countReturns
    ? `\nNumber of calls:   ${(0, _jestMatcherUtils.printReceived)(countCalls)}`
    : '');

// Given a label, return a function which given a string,
// right-aligns it preceding the colon in the label.
const getRightAlignedPrinter = label => {
  // Assume that the label contains a colon.
  const index = label.indexOf(':');
  const suffix = label.slice(index);
  return (string, isExpectedCall) =>
    (isExpectedCall
      ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length))
      : ' '.repeat(Math.max(index - string.length))) +
    string +
    suffix;
};

const printReceivedCallsNegative = (
  expected,
  indexedCalls,
  isOnlyCall,
  iExpectedCall
) => {
  if (indexedCalls.length === 0) {
    return '';
  }

  const label = 'Received:     ';

  if (isOnlyCall) {
    return label + printReceivedArgs(indexedCalls[0], expected) + '\n';
  }

  const printAligned = getRightAlignedPrinter(label);
  return (
    'Received\n' +
    indexedCalls.reduce(
      (printed, [i, args]) =>
        printed +
        printAligned(String(i + 1), i === iExpectedCall) +
        printReceivedArgs(args, expected) +
        '\n',
      ''
    )
  );
};

const printExpectedReceivedCallsPositive = (
  expected,
  indexedCalls,
  expand,
  isOnlyCall,
  iExpectedCall
) => {
  const expectedLine = `Expected: ${printExpectedArgs(expected)}\n`;

  if (indexedCalls.length === 0) {
    return expectedLine;
  }

  const label = 'Received: ';

  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {
    const received = indexedCalls[0][1];

    if (isLineDiffableCall(expected, received)) {
      // Display diff without indentation.
      const lines = [
        (0, _jestMatcherUtils.EXPECTED_COLOR)('- Expected'),
        (0, _jestMatcherUtils.RECEIVED_COLOR)('+ Received'),
        ''
      ];
      const length = Math.max(expected.length, received.length);

      for (let i = 0; i < length; i += 1) {
        if (i < expected.length && i < received.length) {
          if (isEqualValue(expected[i], received[i])) {
            lines.push(`  ${printCommon(received[i])},`);
            continue;
          }

          if (isLineDiffableArg(expected[i], received[i])) {
            const difference = (0, _jestMatcherUtils.diff)(
              expected[i],
              received[i],
              {
                expand
              }
            );

            if (
              typeof difference === 'string' &&
              difference.includes('- Expected') &&
              difference.includes('+ Received')
            ) {
              // Omit annotation in case multiple args have diff.
              lines.push(difference.split('\n').slice(3).join('\n') + ',');
              continue;
            }
          }
        }

        if (i < expected.length) {
          lines.push(
            (0, _jestMatcherUtils.EXPECTED_COLOR)(
              '- ' + (0, _jestMatcherUtils.stringify)(expected[i])
            ) + ','
          );
        }

        if (i < received.length) {
          lines.push(
            (0, _jestMatcherUtils.RECEIVED_COLOR)(
              '+ ' + (0, _jestMatcherUtils.stringify)(received[i])
            ) + ','
          );
        }
      }

      return lines.join('\n') + '\n';
    }

    return expectedLine + label + printReceivedArgs(received, expected) + '\n';
  }

  const printAligned = getRightAlignedPrinter(label);
  return (
    expectedLine +
    'Received\n' +
    indexedCalls.reduce((printed, [i, received]) => {
      const aligned = printAligned(String(i + 1), i === iExpectedCall);
      return (
        printed +
        ((i === iExpectedCall || iExpectedCall === undefined) &&
        isLineDiffableCall(expected, received)
          ? aligned.replace(': ', '\n') +
            printDiffCall(expected, received, expand)
          : aligned + printReceivedArgs(received, expected)) +
        '\n'
      );
    }, '')
  );
};

const indentation = 'Received'.replace(/\w/g, ' ');

const printDiffCall = (expected, received, expand) =>
  received
    .map((arg, i) => {
      if (i < expected.length) {
        if (isEqualValue(expected[i], arg)) {
          return indentation + '  ' + printCommon(arg) + ',';
        }

        if (isLineDiffableArg(expected[i], arg)) {
          const difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {
            expand
          });

          if (
            typeof difference === 'string' &&
            difference.includes('- Expected') &&
            difference.includes('+ Received')
          ) {
            // Display diff with indentation.
            // Omit annotation in case multiple args have diff.
            return (
              difference
                .split('\n')
                .slice(3)
                .map(line => indentation + line)
                .join('\n') + ','
            );
          }
        }
      } // Display + only if received arg has no corresponding expected arg.

      return (
        indentation +
        (i < expected.length
          ? '  ' + (0, _jestMatcherUtils.printReceived)(arg)
          : (0, _jestMatcherUtils.RECEIVED_COLOR)(
              '+ ' + (0, _jestMatcherUtils.stringify)(arg)
            )) +
        ','
      );
    })
    .join('\n');

const isLineDiffableCall = (expected, received) =>
  expected.some(
    (arg, i) => i < received.length && isLineDiffableArg(arg, received[i])
  ); // Almost redundant with function in jest-matcher-utils,
// except no line diff for any strings.

const isLineDiffableArg = (expected, received) => {
  const expectedType = (0, _jestGetType.getType)(expected);
  const receivedType = (0, _jestGetType.getType)(received);

  if (expectedType !== receivedType) {
    return false;
  }

  if ((0, _jestGetType.isPrimitive)(expected)) {
    return false;
  }

  if (
    expectedType === 'date' ||
    expectedType === 'function' ||
    expectedType === 'regexp'
  ) {
    return false;
  }

  if (expected instanceof Error && received instanceof Error) {
    return false;
  }

  if (
    expectedType === 'object' &&
    typeof expected.asymmetricMatch === 'function'
  ) {
    return false;
  }

  if (
    receivedType === 'object' &&
    typeof received.asymmetricMatch === 'function'
  ) {
    return false;
  }

  return true;
};

const printResult = (result, expected) =>
  result.type === 'throw'
    ? 'function call threw an error'
    : result.type === 'incomplete'
    ? 'function call has not returned yet'
    : isEqualValue(expected, result.value)
    ? printCommon(result.value)
    : (0, _jestMatcherUtils.printReceived)(result.value);

// Return either empty string or one line per indexed result,
// so additional empty line can separate from `Number of returns` which follows.
const printReceivedResults = (
  label,
  expected,
  i